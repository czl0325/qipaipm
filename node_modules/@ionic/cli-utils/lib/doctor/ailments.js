"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path = require("path");
const chalk = require("chalk");
const semver = require("semver");
const guards_1 = require("../../guards");
const app_1 = require("../app");
const backends_1 = require("../backends");
const git_1 = require("../git");
const fs_1 = require("../utils/fs");
const npm_1 = require("../utils/npm");
const utils_1 = require("../ionic-angular/utils");
const project_1 = require("../cordova/project");
const config_1 = require("../cordova/config");
class Ailment {
    constructor() {
        this.requiresAuthentication = false;
    }
}
exports.Ailment = Ailment;
class AutomaticallyTreatableAilment extends Ailment {
}
exports.AutomaticallyTreatableAilment = AutomaticallyTreatableAilment;
var Ailments;
(function (Ailments) {
    class AutomaticUpdatesOff extends AutomaticallyTreatableAilment {
        constructor() {
            super(...arguments);
            this.id = 'automatic-updates-off';
        }
        getMessage() {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return (`Automatic Ionic CLI updates are off.\n` +
                    `The Ionic CLI can check for updates in the background and prompt you to install updates automatically.\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const config = yield env.config.load();
                return !config.daemon.updates;
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return [
                    {
                        name: 'Turn on automatic updates',
                        treat: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            const config = yield env.config.load();
                            config.daemon.updates = true;
                        }),
                    },
                ];
            });
        }
    }
    Ailments.AutomaticUpdatesOff = AutomaticUpdatesOff;
    class NpmInstalledLocally extends AutomaticallyTreatableAilment {
        constructor() {
            super(...arguments);
            this.id = 'npm-installed-locally';
        }
        getMessage() {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return (`${chalk.bold('npm')} is installed locally.\n` +
                    `${chalk.bold('npm')} is typically installed globally and may cause some confusion about versions when other CLIs use it.\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return fs_1.pathExists(path.join(env.project.directory, 'node_modules', 'npm'));
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [manager, ...managerArgs] = yield npm_1.pkgManagerArgs(env, { command: 'uninstall', pkg: 'npm' });
                return [
                    {
                        name: `Run: ${chalk.green(manager + ' ' + managerArgs.join(' '))}`,
                        treat: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            yield env.shell.run(manager, managerArgs, {});
                        }),
                    },
                ];
            });
        }
    }
    Ailments.NpmInstalledLocally = NpmInstalledLocally;
    class IonicCLIInstalledLocally extends AutomaticallyTreatableAilment {
        constructor() {
            super(...arguments);
            this.id = 'ionic-installed-locally';
        }
        getMessage() {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return (`The Ionic CLI is installed locally.\n` +
                    `While the CLI can run locally, there's no longer a reason to have it installed locally and it may cause some confusion over configuration and versions.\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return fs_1.pathExists(path.join(env.project.directory, 'node_modules', 'ionic'));
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [manager, ...managerArgs] = yield npm_1.pkgManagerArgs(env, { command: 'uninstall', pkg: 'ionic' });
                return [
                    {
                        name: `Run: ${chalk.green(manager + ' ' + managerArgs.join(' '))}`,
                        treat: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            yield env.shell.run(manager, managerArgs, {});
                        }),
                    },
                ];
            });
        }
    }
    Ailments.IonicCLIInstalledLocally = IonicCLIInstalledLocally;
    class GitNotUsed extends Ailment {
        constructor() {
            super(...arguments);
            this.id = 'git-not-used';
        }
        getMessage() {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return (`Git doesn't appear to be in use.\n` +
                    `We highly recommend using source control software such as git (${chalk.bold('https://git-scm.com')}) to track changes in your code throughout time.\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!(yield git_1.isRepoInitialized(env))) {
                    return true;
                }
                const cmdInstalled = yield env.shell.cmdinfo('git', ['--version']);
                if (!cmdInstalled) {
                    return true;
                }
                const commitCount = Number(yield env.shell.run('git', ['rev-list', '--count', 'HEAD'], { showCommand: false }));
                return commitCount <= 1;
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return [
                    {
                        name: `Download git if you don't have it installed: ${chalk.bold('https://git-scm.com/downloads')}`,
                    },
                    {
                        name: `Learn the basics: ${chalk.bold('https://try.github.io')}`,
                    },
                    {
                        name: `Make your first commit and start tracking code changes! 😍`,
                    },
                ];
            });
        }
    }
    Ailments.GitNotUsed = GitNotUsed;
    class GitConfigInvalid extends AutomaticallyTreatableAilment {
        constructor() {
            super(...arguments);
            this.id = 'git-config-invalid';
            this.requiresAuthentication = true;
        }
        getMessage(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const project = yield env.project.load();
                const appId = project.app_id;
                return (`App linked to ${chalk.bold(appId)} with invalid git configuration.\n` +
                    `This app is linked to an app on Ionic (${chalk.bold(appId)}), but the git configuration is not valid.\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const config = yield env.config.load();
                const project = yield env.project.load();
                const appId = project.app_id;
                if (config.backend !== backends_1.BACKEND_PRO) {
                    return false;
                }
                if (!appId) {
                    return false;
                }
                if (!(yield git_1.isRepoInitialized(env))) {
                    return false;
                }
                const remote = yield git_1.getIonicRemote(env);
                if (!remote) {
                    return true;
                }
                const token = yield env.session.getUserToken();
                const appLoader = new app_1.App(token, env.client);
                const app = yield appLoader.load(appId);
                if (app.repo_url !== remote) {
                    return true;
                }
                return false;
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const args = ['git', 'remote'];
                return [
                    {
                        name: `Run: ${chalk.green('ionic ' + args.join(' '))}`,
                        treat: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            yield env.runCommand(args);
                        }),
                    },
                ];
            });
        }
    }
    Ailments.GitConfigInvalid = GitConfigInvalid;
    class IonicAngularUpdateAvailable extends Ailment {
        constructor() {
            super(...arguments);
            this.id = 'ionic-angular-update-available';
        }
        getVersionPair(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!this.currentVersion || !this.latestVersion) {
                    this.currentVersion = yield utils_1.getIonicAngularVersion(env, env.project);
                    this.latestVersion = yield npm_1.pkgLatestVersion(env, 'ionic-angular');
                }
                if (!this.currentVersion || !this.latestVersion) {
                    return ['0.0.0', '0.0.0'];
                }
                return [this.currentVersion, this.latestVersion];
            });
        }
        getMessage(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [currentVersion, latestVersion] = yield this.getVersionPair(env);
                return (`Update available for Ionic Framework.\n` +
                    `An update is available for ${chalk.bold('ionic-angular')} (${chalk.cyan(currentVersion)} => ${chalk.cyan(latestVersion)}).\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const project = yield env.project.load();
                const [currentVersion, latestVersion] = yield this.getVersionPair(env);
                if (project.type !== 'ionic-angular') {
                    return false;
                }
                const diff = semver.diff(currentVersion, latestVersion);
                return diff === 'minor' || diff === 'patch';
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [, latestVersion] = yield this.getVersionPair(env);
                const args = yield npm_1.pkgManagerArgs(env, { pkg: `ionic-angular@${latestVersion ? latestVersion : 'latest'}` });
                return [
                    {
                        name: `Visit ${chalk.bold('https://github.com/ionic-team/ionic/releases')} for each upgrade's instructions`,
                    },
                    {
                        name: `If no instructions, run: ${chalk.green(args.join(' '))}`,
                    },
                    {
                        name: `Watch for npm warnings about peer dependencies--they may need manual updating`,
                    },
                ];
            });
        }
    }
    Ailments.IonicAngularUpdateAvailable = IonicAngularUpdateAvailable;
    class IonicAngularMajorUpdateAvailable extends Ailment {
        constructor() {
            super(...arguments);
            this.id = 'ionic-angular-major-update-available';
        }
        getVersionPair(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!this.currentVersion || !this.latestVersion) {
                    this.currentVersion = yield utils_1.getIonicAngularVersion(env, env.project);
                    this.latestVersion = yield npm_1.pkgLatestVersion(env, 'ionic-angular');
                }
                if (!this.currentVersion || !this.latestVersion) {
                    return ['0.0.0', '0.0.0'];
                }
                return [this.currentVersion, this.latestVersion];
            });
        }
        getMessage(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [currentVersion, latestVersion] = yield this.getVersionPair(env);
                return (`Major update available for Ionic Framework.\n` +
                    `A major update is available for ${chalk.bold('ionic-angular')} (${chalk.cyan(currentVersion)} => ${chalk.cyan(latestVersion)}).\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const project = yield env.project.load();
                const [currentVersion, latestVersion] = yield this.getVersionPair(env);
                if (project.type !== 'ionic-angular') {
                    return false;
                }
                const diff = semver.diff(currentVersion, latestVersion);
                return diff === 'major';
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return [
                    {
                        name: `Visit ${chalk.bold('http://blog.ionic.io')} and ${chalk.bold('https://github.com/ionic-team/ionic/releases')} for upgrade instructions`,
                    },
                ];
            });
        }
    }
    Ailments.IonicAngularMajorUpdateAvailable = IonicAngularMajorUpdateAvailable;
    class AppScriptsUpdateAvailable extends AutomaticallyTreatableAilment {
        constructor() {
            super(...arguments);
            this.id = 'app-scripts-update-available';
        }
        getVersionPair(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!this.currentVersion || !this.latestVersion) {
                    this.currentVersion = yield utils_1.getAppScriptsVersion(env, env.project);
                    this.latestVersion = yield npm_1.pkgLatestVersion(env, '@ionic/app-scripts');
                }
                if (!this.currentVersion || !this.latestVersion) {
                    return ['0.0.0', '0.0.0'];
                }
                return [this.currentVersion, this.latestVersion];
            });
        }
        getMessage(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [currentVersion, latestVersion] = yield this.getVersionPair(env);
                return (`Update available for ${chalk.bold('@ionic/app-scripts')}.\n` +
                    `An update is available for ${chalk.bold('@ionic/app-scripts')} (${chalk.cyan(currentVersion)} => ${chalk.cyan(latestVersion)}).\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const project = yield env.project.load();
                const [currentVersion, latestVersion] = yield this.getVersionPair(env);
                if (project.type !== 'ionic-angular') {
                    return false;
                }
                const diff = semver.diff(currentVersion, latestVersion);
                return diff === 'minor' || diff === 'patch';
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [, latestVersion] = yield this.getVersionPair(env);
                const [manager, ...managerArgs] = yield npm_1.pkgManagerArgs(env, { pkg: `@ionic/app-scripts@${latestVersion ? latestVersion : 'latest'}`, saveDev: true });
                return [
                    {
                        name: `Run: ${chalk.green(manager + ' ' + managerArgs.join(' '))}`,
                        treat: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            yield env.shell.run(manager, managerArgs, {});
                        }),
                    },
                ];
            });
        }
    }
    Ailments.AppScriptsUpdateAvailable = AppScriptsUpdateAvailable;
    class AppScriptsMajorUpdateAvailable extends Ailment {
        constructor() {
            super(...arguments);
            this.id = 'app-scripts-major-update-available';
        }
        getVersionPair(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!this.currentVersion || !this.latestVersion) {
                    this.currentVersion = yield utils_1.getAppScriptsVersion(env, env.project);
                    this.latestVersion = yield npm_1.pkgLatestVersion(env, '@ionic/app-scripts');
                }
                if (!this.currentVersion || !this.latestVersion) {
                    return ['0.0.0', '0.0.0'];
                }
                return [this.currentVersion, this.latestVersion];
            });
        }
        getMessage(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const [currentVersion, latestVersion] = yield this.getVersionPair(env);
                return (`Major update available for ${chalk.bold('@ionic/app-scripts')}.\n` +
                    `A major update is available for ${chalk.bold('@ionic/app-scripts')} (${chalk.cyan(currentVersion)} => ${chalk.cyan(latestVersion)}).\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const project = yield env.project.load();
                const [currentVersion, latestVersion] = yield this.getVersionPair(env);
                if (project.type !== 'ionic-angular') {
                    return false;
                }
                const diff = semver.diff(currentVersion, latestVersion);
                return diff === 'major';
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return [
                    {
                        name: `Visit ${chalk.bold('https://github.com/ionic-team/ionic-app-scripts/releases')} for upgrade instructions`,
                    },
                ];
            });
        }
    }
    Ailments.AppScriptsMajorUpdateAvailable = AppScriptsMajorUpdateAvailable;
    class UnsavedCordovaPlatforms extends AutomaticallyTreatableAilment {
        constructor() {
            super(...arguments);
            this.id = 'unsaved-cordova-platforms';
        }
        getMessage(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return (`Cordova platforms unsaved.\n` +
                    `There are Cordova platforms installed that are not saved in ${chalk.bold('config.xml')} or ${chalk.bold('package.json')}. It is good practice to manage Cordova platforms and their versions. See ${chalk.bold('https://cordova.apache.org/docs/en/latest/platform_plugin_versioning_ref/')} for more information.\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const project = yield env.project.load();
                const packageJson = yield env.project.loadPackageJson();
                if (!project.integrations.cordova) {
                    return false;
                }
                if (!guards_1.isCordovaPackageJson(packageJson)) {
                    return false;
                }
                const platforms = yield project_1.getPlatforms(env.project.directory);
                const conf = yield config_1.ConfigXml.load(env.project.directory);
                const engines = conf.getPlatformEngines();
                const engineNames = new Set([...engines.map(e => e.name)]);
                const packageJsonPlatforms = new Set([...packageJson.cordova.platforms]);
                const configXmlDiff = platforms.map(p => p.name).filter(p => !engineNames.has(p));
                const packageJsonDiff = platforms.map(p => p.name).filter(p => !packageJsonPlatforms.has(p));
                return configXmlDiff.length > 0 || packageJsonDiff.length > 0;
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const args = ['cordova', 'platform', 'save'];
                return [
                    {
                        name: `Run: ${chalk.green('ionic ' + args.join(' '))}`,
                        treat: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            yield env.runCommand(args);
                        }),
                    },
                ];
            });
        }
    }
    Ailments.UnsavedCordovaPlatforms = UnsavedCordovaPlatforms;
    class CordovaPlatformsCommitted extends Ailment {
        constructor() {
            super(...arguments);
            this.id = 'cordova-platforms-committed';
        }
        getMessage() {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return (`Cordova ${chalk.bold('platforms/')} directory is committed to git.\n` +
                    `Cordova considers ${chalk.bold('platforms/')} and ${chalk.bold('plugins/')} build artifacts${chalk.cyan('[1]')}, and routinely overwrites files.\n\n` +
                    `While committing these files might be necessary for some projects${chalk.cyan('[2]')}, generally platforms should be configured using ${chalk.bold('config.xml')} and Cordova hooks${chalk.cyan('[3]')} so that your project is more portable and SDK updates are easier.\n\n` +
                    `${chalk.cyan('[1]')}: ${chalk.bold('https://cordova.apache.org/docs/en/latest/reference/cordova-cli/#version-control')}\n` +
                    `${chalk.cyan('[2]')}: ${chalk.bold('https://cordova.apache.org/docs/en/latest/reference/cordova-cli/#platforms')}\n` +
                    `${chalk.cyan('[3]')}: ${chalk.bold('https://cordova.apache.org/docs/en/latest/guide/appdev/hooks/index.html')}\n` +
                    `\n`).trim();
            });
        }
        detected(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!(yield git_1.isRepoInitialized(env))) {
                    return false;
                }
                const cmdInstalled = yield env.shell.cmdinfo('git', ['--version']);
                if (!cmdInstalled) {
                    return false;
                }
                const files = (yield env.shell.run('git', ['ls-tree', '--name-only', 'HEAD'], { showCommand: false })).split('\n');
                return files.includes('platforms'); // TODO
            });
        }
        getTreatmentSteps(env) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                return [];
            });
        }
    }
    Ailments.CordovaPlatformsCommitted = CordovaPlatformsCommitted;
    Ailments.ALL = [
        AutomaticUpdatesOff,
        NpmInstalledLocally,
        IonicCLIInstalledLocally,
        GitNotUsed,
        GitConfigInvalid,
        IonicAngularUpdateAvailable,
        IonicAngularMajorUpdateAvailable,
        AppScriptsUpdateAvailable,
        AppScriptsMajorUpdateAvailable,
        UnsavedCordovaPlatforms,
        CordovaPlatformsCommitted,
    ];
})(Ailments = exports.Ailments || (exports.Ailments = {}));
